{"version":3,"file":"index.umd.js","sources":["../src/transition.ts","../src/particle.ts","../src/particle-source.ts","../src/utils.ts","../src/body.ts","../src/physical-particle.ts","../src/physical-particle-source.ts","../src/scene.ts"],"sourcesContent":["import { Vector3, Quaternion } from 'three'\nimport { ParticleState } from '~/particle'\n\nexport interface Pausable {\n  pause(): void\n}\n\nexport type TransitionExecutor = (\n  transition: ParticleState,\n  complete: () => void\n) => Pausable | void | undefined\n\nexport class Transition implements ParticleState {\n  private animation?: Pausable\n  public readonly position: Vector3 = new Vector3()\n  public readonly quaternion: Quaternion = new Quaternion()\n  public readonly scale: Vector3 = new Vector3()\n\n  public static show: TransitionExecutor = (transition, complete) => {\n    transition.scale.set(1, 1, 1)\n    complete()\n  }\n\n  public static hide: TransitionExecutor = (transition, complete) => {\n    transition.scale.set(0, 0, 0)\n    complete()\n  }\n\n  public static compose(\n    ...executors: TransitionExecutor[]\n  ): TransitionExecutor {\n    return (transition: ParticleState, complete: () => void): Pausable => {\n      let animationsToComplete = executors.length\n      const animations = executors.map(executor => executor(transition, () => {\n        --animationsToComplete || complete()\n      }))\n\n      return {\n        pause: () => animations.forEach(animation => {\n          animation && animation.pause()\n        })\n      }\n    }\n  }\n\n  public start(executor: TransitionExecutor, complete: () => void): void {\n    this.stop()\n    this.animation = executor(this, () => {\n      complete()\n      this.animation = undefined\n    }) as Pausable | undefined\n  }\n\n  public stop(): void {\n    if (this.animation && !this.animation.pause) console.log(this.animation)\n    this.animation && this.animation.pause()\n  }\n\n  public dispose(): void {\n    this.animation && this.animation.pause()\n    this.animation = undefined\n  }\n}\n","import { Vector3, Quaternion, Matrix4 } from 'three'\nimport { Transition, TransitionExecutor } from '~/transition'\n\nexport interface ParticleState {\n  position: Vector3\n  quaternion: Quaternion\n  scale: Vector3\n}\n\nexport class Particle implements ParticleState {\n  public readonly position: Vector3 = new Vector3()\n  public readonly quaternion: Quaternion = new Quaternion()\n  public readonly scale: Vector3 = new Vector3(1, 1, 1)\n  public readonly matrix: Matrix4 = new Matrix4()\n  public readonly transition: Transition = new Transition()\n  public appended: boolean = false\n  public removed: boolean = false\n\n  public get needsUpdate(): boolean {\n    return this.appended || this.removed\n  }\n\n  public append(\n    transition?: TransitionExecutor,\n    complete?: (particle: this) => void\n  ): void {\n    this.appended = true\n    this.transition.start(transition || Transition.show, () => {\n      complete && complete(this)\n    })\n  }\n\n  public remove(\n    transition?: TransitionExecutor,\n    complete?: (particle: this) => void\n  ): void {\n    this.transition.start(transition || Transition.hide, () => {\n      this.removed = true\n      this.appended = false\n      complete && complete(this)\n    })\n  }\n\n  public update(): boolean {\n    if (!this.needsUpdate) return false\n\n    this.matrix.compose(\n      this.position.clone().add(this.transition.position),\n      this.quaternion.clone().multiply(this.transition.quaternion),\n      this.scale.clone().multiply(this.transition.scale)\n    )\n\n    if (this.removed) this.removed = false\n\n    return true\n  }\n\n  public dispose(): void {\n    this.transition.dispose()\n  }\n}\n","import {\n  Color,\n  Object3D,\n  Vector3,\n  Geometry,\n  BufferGeometry,\n  InstancedMesh\n} from 'three'\n\nimport { GLTF, GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader'\nimport { Particle } from '~/particle'\nimport { TransitionExecutor } from '~/transition'\nimport { mergeGLTF, ColoredMaterial } from '~/utils'\n\nenum ParticleSourceMutation {\n  Append = 1,\n  Remove = -1\n}\n\ninterface ParticleSourceTransitionExecutors {\n  append?: TransitionExecutor\n  remove?: TransitionExecutor\n}\n\nexport interface ParticleSourceMutationExecutors<\n  P extends Particle = Particle\n> {\n  prepare?: (particle: P) => void\n  complete?: (particle: P) => void\n  transition?: TransitionExecutor\n}\n\nexport interface ParticleSourceParameters {\n  geometry?: Geometry | BufferGeometry\n  material?: ColoredMaterial | ColoredMaterial[]\n  count?: number\n  color?: Color | number\n  autoScale?: number\n  autoScaleAxis?: 'x' | 'y' | 'z' | 'average'\n  transition?: ParticleSourceTransitionExecutors\n}\n\nexport class ParticleSource<P extends Particle = Particle> extends Object3D {\n  private mesh?: InstancedMesh\n  private _geometry?: Geometry | BufferGeometry\n  private _material?: ColoredMaterial | ColoredMaterial[]\n  private _color!: Color | number\n\n  protected autoScale?: number\n  protected autoScaleAxis: 'x' | 'y' | 'z' | 'average'\n\n  public particles: P[] = []\n  public appendedParticles: number = 0\n  public transition: ParticleSourceTransitionExecutors\n  public count: number\n\n  public constructor({\n    geometry = undefined,\n    material = undefined,\n    count = 0,\n    color = 0xffffff,\n    autoScale = undefined,\n    autoScaleAxis = 'average',\n    transition = {}\n  }: ParticleSourceParameters = {}) {\n    super()\n\n    this.transition = transition\n    this.autoScale = autoScale\n    this.autoScaleAxis = autoScaleAxis\n    this.geometry = geometry\n    this.material = material\n    this.color = color\n    this.count = count\n  }\n\n  public get generated(): boolean {\n    return !!this.mesh\n  }\n\n  public get geometry(): Geometry | BufferGeometry | undefined {\n    return this._geometry\n  }\n\n  public set geometry(v: Geometry | BufferGeometry | undefined) {\n    this._geometry = v\n    this.updateGeometry()\n  }\n\n  public get material(): ColoredMaterial | ColoredMaterial[] | undefined {\n    return this._material\n  }\n\n  public set material(v: ColoredMaterial | ColoredMaterial[] | undefined) {\n    this._material = v\n    this.updateMaterial()\n  }\n\n  public get color(): Color | number {\n    return this._color\n  }\n\n  public set color(v: Color | number) {\n    this._color = v\n\n    if (!this.material) return\n\n    if (Array.isArray(this.material)) {\n      this.material.forEach(material => material.color.set(v as Color))\n    } else {\n      this.material.color.set(v as Color)\n    }\n  }\n\n  protected updateGeometry(): void {\n    if (!this.geometry) return\n\n    if (this.autoScale !== undefined) {\n      this.geometry.boundingBox || this.geometry.computeBoundingBox()\n\n      const size = this.geometry.boundingBox.getSize(new Vector3())\n      const scale = this.autoScaleAxis === 'average'\n        ? this.autoScale / (size.x + size.y + size.z) * 3\n        : this.autoScale / size[this.autoScaleAxis]\n\n      this.geometry.scale(scale, scale, scale)\n    }\n\n    if (this.mesh) {\n      this.mesh.geometry = this.geometry\n    }\n  }\n\n  protected updateMaterial(): void {\n    if (!this.mesh || !this.material) return\n\n    if (Array.isArray(this.material)) {\n      this.material.forEach(material => material.color.set(this.color as Color))\n    } else {\n      this.material.color.set(this.color as Color)\n    }\n\n    this.mesh.material = this.material\n  }\n\n  protected createParticle(): P {\n    return new Particle() as P\n  }\n\n  protected prepareParticle(\n    mutation: ParticleSourceMutation,\n    prepare?: (particle: P) => void\n  ): P {\n    if (!this.mesh) throw new Error(\n      'The mesh and particles have not been generated, ' +\n      'call generate() before calling appendParticle() or removeParticle()'\n    )\n\n    let particle!: P\n\n    switch (mutation) {\n      case ParticleSourceMutation.Append:\n        if (this.appendedParticles >= this.mesh.count) throw new Error(\n          `All ${this.mesh.count} particles have already been appended, ` +\n          'increase count and call generate() to append more particles.'\n        )\n\n        particle = this.particles[this.appendedParticles++]\n\n        break\n\n      case ParticleSourceMutation.Remove:\n        if (this.appendedParticles <= 0) throw new Error(\n          `All ${this.mesh.count} particles have already been removed, ` +\n          'you cannot remove more particles.'\n        )\n\n        particle = this.particles[--this.appendedParticles]\n\n        break\n    }\n\n    prepare && prepare(particle)\n\n    return particle\n  }\n\n  public useGLTF(gltf: GLTF): void {\n    const { geometry, material } = mergeGLTF(gltf)\n\n    this.geometry = geometry\n    this.material = material\n  }\n\n  public loadGLTF(url: string, complete?: (gltf: GLTF) => void): void {\n    new GLTFLoader().load(url, (gltf) => {\n      this.useGLTF(gltf)\n      complete && complete(gltf)\n    })\n  }\n\n  public generate(): void {\n    if (!this.geometry || !this.material) throw new Error(\n      'geometry and material must be set before calling generate()'\n    )\n\n    const {\n      particles,\n      count\n    } = this\n\n    this.disposeMesh()\n\n    this.mesh = new InstancedMesh(this.geometry, this.material, count)\n    this.mesh.frustumCulled = false\n\n    this.appendedParticles = Math.min(this.appendedParticles, count)\n    while (particles.length < count) particles.push(this.createParticle())\n    this.disposeParticles(count)\n\n    this.add(this.mesh)\n  }\n\n  public disposeMesh(): void {\n    if (!this.mesh) return\n\n    this.remove(this.mesh)\n    this.mesh = undefined\n  }\n\n  public disposeParticles(index: number = 0): void {\n    this.particles.splice(index).forEach(particle => particle.dispose())\n  }\n\n  public disposeGeometry(): void {\n    if (!this.geometry) return\n\n    this.geometry.dispose()\n    this.geometry = undefined\n  }\n\n  public disposeMaterial(): void {\n    if (!this.material) return\n\n    Array.isArray(this.material)\n      ? this.material.forEach(material => material.dispose())\n      : this.material.dispose()\n\n    this.material = undefined\n  }\n\n  public update(): void {\n    if (!this.mesh) return\n\n    const mesh = this.mesh\n\n    this.particles.forEach((particle, index) => {\n      if (!particle.update()) return\n      mesh.setMatrixAt(index, particle.matrix)\n      mesh.instanceMatrix.needsUpdate = true\n    })\n  }\n\n  public appendParticle({\n    prepare = undefined,\n    complete = undefined,\n    transition = this.transition.append\n  }: ParticleSourceMutationExecutors<P> = {}): void {\n    this\n      .prepareParticle(ParticleSourceMutation.Append, prepare)\n      .append(transition, complete)\n  }\n\n  public removeParticle({\n    prepare = undefined,\n    complete = undefined,\n    transition = this.transition.remove\n  }: ParticleSourceMutationExecutors<P> = {}): void {\n    this\n      .prepareParticle(ParticleSourceMutation.Remove, prepare)\n      .remove(transition, complete)\n  }\n\n  public appendParticles({\n    amount = Infinity,\n    complete = undefined,\n    completeAll = undefined,\n    ...executors\n  }: ParticleSourceMutationExecutors<P> & {\n    amount?: number\n    completeAll?: (particles: P[]) => void\n  } = {}): void {\n    const particles: P[] = []\n    amount = Math.min(amount, this.count - this.appendedParticles)\n\n    for (var i = 0; i < amount; i++) this.appendParticle({\n      ...executors,\n      complete: (particle) => {\n        particles.push(particle)\n        complete && complete(particle)\n        particles.length === amount && completeAll && completeAll(particles)\n      }\n    })\n  }\n\n  public removeParticles({\n    amount = Infinity,\n    complete = undefined,\n    completeAll = undefined,\n    ...executors\n  }: ParticleSourceMutationExecutors<P> & {\n    amount?: number\n    completeAll?: (particles: P[]) => void\n  } = {}): void {\n    const particles: P[] = []\n    amount = Math.min(amount, this.appendedParticles)\n\n    for (var i = 0; i < amount; i++) this.removeParticle({\n      ...executors,\n      complete: (particle) => {\n        particles.push(particle)\n        complete && complete(particle)\n        particles.length === amount && completeAll && completeAll(particles)\n      }\n    })\n  }\n}\n","import {\n  Object3D,\n  Mesh,\n  Line,\n  Points,\n  InstancedMesh,\n  Material,\n  Geometry,\n  BufferGeometry,\n  InstancedBufferGeometry,\n  Color\n} from 'three'\n\nimport { GLTF } from 'three/examples/jsm/loaders/GLTFLoader'\n\nimport {\n  BufferGeometryUtils\n} from 'three/examples/jsm/utils/BufferGeometryUtils'\n\nexport type ColoredMaterial = Material & { color: Color }\n\nexport function isMesh(object: Object3D): object is Mesh {\n  return (object as Mesh).isMesh\n}\n\nexport function isLine(object: Object3D): object is Line {\n  return (object as Line).isLine\n}\n\nexport function isPoints(object: Object3D): object is Points {\n  return (object as Points).isPoints\n}\n\nexport function isInstancedMesh(object: Object3D): object is InstancedMesh {\n  return (object as InstancedMesh).isInstancedMesh\n}\n\nexport function isBufferGeometry(\n  geometry: Geometry | BufferGeometry\n): geometry is BufferGeometry {\n  return (geometry as BufferGeometry).isBufferGeometry\n}\n\nexport function isInstancedBufferGeometry(\n  geometry: Geometry | BufferGeometry | InstancedBufferGeometry\n): geometry is InstancedBufferGeometry {\n  return (geometry as unknown as {\n    isInstancedBufferGeometry: boolean\n  }).isInstancedBufferGeometry\n}\n\nexport function mergeGLTF(gltf: GLTF): {\n  geometry: BufferGeometry\n  material: ColoredMaterial | ColoredMaterial[]\n} {\n  const geometries: BufferGeometry[] = []\n  const materials: ColoredMaterial[] = []\n\n  gltf.scene.traverse((mesh) => {\n    if (!isMesh(mesh)) return\n\n    mesh.updateWorldMatrix(true, false)\n    mesh.geometry.applyMatrix(mesh.matrixWorld)\n\n    geometries.push(mesh.geometry as BufferGeometry)\n    materials.push(mesh.material as ColoredMaterial)\n  })\n\n  if (!geometries.length) throw new Error(\n    'Could not find any geometry in GLTF scene'\n  )\n\n  return {\n    geometry: geometries.length === 1\n      ? geometries[0]\n      : BufferGeometryUtils.mergeBufferGeometries(geometries, true),\n\n    material: materials.length === 1\n      ? materials[0]\n      : materials\n  }\n}\n","import { Body as BaseBody, Shape } from 'cannon'\n\nexport class Body extends BaseBody {\n  public removeShape(shape: Shape): this {\n    const index = this.shapes.indexOf(shape)\n\n    if (index !== -1) {\n      this.shapes.splice(index, 1)\n      this.shapeOffsets.splice(index, 1)\n      this.shapeOrientations.splice(index, 1)\n\n      this.updateMassProperties()\n      this.updateBoundingRadius()\n\n      this.aabbNeedsUpdate = true\n    }\n\n    return this\n  }\n\n  public clearShapes(update: boolean = true): this {\n    if (this.shapes.length) {\n      this.shapes.splice(0)\n      this.shapeOffsets.splice(0)\n      this.shapeOrientations.splice(0)\n\n      if (update) {\n        this.updateMassProperties()\n        this.updateBoundingRadius()\n\n        this.aabbNeedsUpdate = true\n      }\n    }\n\n    return this\n  }\n}\n","import { Shape, Vec3 } from 'cannon'\nimport { Vector3, Quaternion } from 'three'\nimport { Particle } from '~/particle'\nimport { Body } from '~/body'\nimport { TransitionExecutor } from '~/transition'\n\nexport class PhysicalParticle extends Particle {\n  protected readonly freezeDelay: number = Infinity\n  protected readonly freezeVelocityFactor: Vec3 = new Vec3(0.9, 1, 0.9)\n  protected readonly freezeAngularVelocityFactor: Vec3 = new Vec3(1, 1, 1)\n  protected readonly freezeThreshold: number = 0.001\n  protected freezeTimeout?: number\n  protected freezing: boolean = false\n  protected frozen: boolean = false\n\n  public readonly body: Body\n\n  public constructor() {\n    super()\n    this.body = new Body(this.bodyParameters)\n  }\n\n  protected get bodyParameters(): { [parameter: string]: unknown } {\n    return {\n      mass: 1,\n      type: Body.DYNAMIC\n    }\n  }\n\n  protected freeze(): void {\n    const { velocity,  angularVelocity } = this.body\n\n    if (velocity.almostZero(this.freezeThreshold)) {\n      this.frozen = true\n      this.freezing = false\n\n      this.body.type = Body.STATIC\n\n      return\n    }\n\n    const { freezeVelocityFactor, freezeAngularVelocityFactor } = this\n\n    velocity.x *= freezeVelocityFactor.x\n    velocity.y *= freezeVelocityFactor.y\n    velocity.z *= freezeVelocityFactor.z\n\n    angularVelocity.x *= freezeAngularVelocityFactor.x\n    angularVelocity.y *= freezeAngularVelocityFactor.y\n    angularVelocity.z *= freezeAngularVelocityFactor.z\n  }\n\n  protected requestFreeze(): void {\n    if (this.freezeDelay === Infinity) return\n    this.cancelFreeze()\n    this.freezeTimeout = window.setTimeout(() => {\n      this.freezing = true\n    }, this.freezeDelay)\n  }\n\n  protected cancelFreeze(): void {\n    if (this.freezeTimeout === undefined) return\n    clearTimeout(this.freezeTimeout)\n    this.freezeTimeout = undefined\n  }\n\n  public append(\n    transition?: TransitionExecutor,\n    complete?: (particle: this) => void\n  ): void {\n    this.freezing = this.frozen = false\n    this.body.type = Body.DYNAMIC\n    super.append(transition, (particle) => {\n      this.requestFreeze()\n      complete && complete(particle)\n    })\n  }\n\n  public remove(\n    transition?: TransitionExecutor,\n    complete?: (particle: this) => void\n  ): void {\n    this.cancelFreeze()\n    super.remove(transition, complete)\n  }\n\n  public update(): boolean {\n    if (!this.needsUpdate) return false\n    this.freezing && this.freeze()\n    this.frozen || this.synchronizeBody()\n    return super.update()\n  }\n\n  public clearBodyShape(): void {\n    this.body.clearShapes()\n  }\n\n  public setBodyShape(shape: Shape): void {\n    this.body.clearShapes(false)\n    this.body.addShape(shape)\n  }\n\n  public synchronizeBody(): void {\n    this.position.copy(this.body.position as unknown as Vector3)\n    this.quaternion.copy(this.body.quaternion as unknown as Quaternion)\n  }\n\n  public resetBodyPosition(): void {\n    const { x, y, z } = this.position\n    this.body.position.set(x, y, z)\n  }\n\n  public resetBodyQuaternion(): void {\n    const { x, y, z, w } = this.quaternion\n    this.body.quaternion.set(x, y, z, w)\n  }\n\n  public resetBodyVelocity(): void {\n    this.body.velocity.set(0, 0, 0)\n  }\n\n  public resetBodyAngularVelocity(): void {\n    this.body.angularVelocity.set(0, 0, 0)\n  }\n}\n","import { World, Box, Vec3, Shape } from 'cannon'\nimport { PhysicalParticle } from '~/physical-particle'\n\nimport {\n  ParticleSource,\n  ParticleSourceParameters,\n  ParticleSourceMutationExecutors\n} from '~/particle-source'\n\nexport interface PhysicalParticleSourceParameters\n  extends ParticleSourceParameters {\n  world: World\n}\n\nexport class PhysicalParticleSource extends ParticleSource<PhysicalParticle> {\n  public readonly world: World\n  protected shape?: Shape\n\n  public constructor({\n    world,\n    ...parameters\n  }: PhysicalParticleSourceParameters) {\n    super(parameters)\n    this.world = world\n  }\n\n  protected updateGeometry(): void {\n    super.updateGeometry()\n\n    if (this.geometry) {\n      const shape = this.shape = this.createShape()\n      this.particles.forEach(particle => particle.setBodyShape(shape))\n    } else {\n      this.particles.forEach(particle => particle.clearBodyShape())\n    }\n  }\n\n  protected createShape(): Shape {\n    this.geometry!.boundingBox || this.geometry!.computeBoundingBox()\n\n    const box = this.geometry!.boundingBox\n\n    return new Box(new Vec3(\n      (box.max.x - box.min.x) / 2,\n      (box.max.y - box.min.y) / 2,\n      (box.max.z - box.min.z) / 2\n    ))\n  }\n\n  protected createParticle(): PhysicalParticle {\n    const particle = new PhysicalParticle()\n    this.shape && particle.setBodyShape(this.shape)\n    return particle\n  }\n\n  public appendParticle({\n    prepare = undefined,\n    ...executors\n  }: ParticleSourceMutationExecutors<PhysicalParticle> = {}): void {\n    super.appendParticle({\n      ...executors,\n      prepare: (particle) => {\n        particle.resetBodyVelocity()\n        particle.resetBodyAngularVelocity()\n\n        prepare && prepare(particle)\n\n        particle.resetBodyPosition()\n        particle.resetBodyQuaternion()\n\n        this.world.addBody(particle.body)\n      }\n    })\n  }\n\n  public removeParticle({\n    complete = undefined,\n    ...executors\n  }: ParticleSourceMutationExecutors<PhysicalParticle> = {}): void {\n    super.removeParticle({\n      ...executors,\n      complete: (particle) => {\n        this.world.remove(particle.body)\n        complete && complete(particle)\n      }\n    })\n  }\n}\n","import {\n  Scene as BaseScene,\n  Material,\n  Mesh,\n  WebGLRenderer,\n  Camera,\n  Geometry,\n  BufferGeometry,\n  Group,\n  Line,\n  Points,\n  InstancedMesh\n} from 'three'\n\nimport {\n  isMesh,\n  isLine,\n  isPoints,\n  isInstancedMesh,\n  isInstancedBufferGeometry\n} from '~/utils'\n\ntype RenderCallback = (\n  renderer: WebGLRenderer,\n  scene: BaseScene,\n  camera: Camera,\n  geometry: Geometry | BufferGeometry,\n  material: Material,\n  group: Group\n) => void\n\nexport class Scene extends BaseScene {\n  private _onBeforeRender: RenderCallback = this.setOverrideMaterial\n  private _onAfterRender: RenderCallback = this.unsetOverrideMaterial\n  private _overrideMaterial?: Material\n  private objectMaterials?: { [id: number]: Material | Material[] }\n  private drawableObjects?: (Mesh | Line | Points | InstancedMesh)[]\n  private instancedOverrideMaterials: {\n    [id: number]: { version: number, material: Material }\n  } = {}\n\n  public drawableObjectsNeedUpdate: boolean = false\n  public handleInstancedOverrideMaterials: boolean = true\n\n  public get onBeforeRender(): RenderCallback {\n    return this._onBeforeRender\n  }\n\n  public set onBeforeRender(v: RenderCallback) {\n    if (v) {\n      this._onBeforeRender = (...parameters) => {\n        this.setOverrideMaterial()\n        v(...parameters)\n      }\n    } else {\n      this._onBeforeRender = this.setOverrideMaterial\n    }\n  }\n\n  public get onAfterRender(): RenderCallback {\n    return this._onAfterRender\n  }\n\n  public set onAfterRender(v: RenderCallback) {\n    if (v) {\n      this._onAfterRender = (...parameters) => {\n        this.unsetOverrideMaterial()\n        v(...parameters)\n      }\n    } else {\n      this._onAfterRender = this.unsetOverrideMaterial\n    }\n  }\n\n  private setOverrideMaterial(): void {\n    if (!this.handleInstancedOverrideMaterials) return\n\n    const overrideMaterial = this.overrideMaterial\n\n    if (!overrideMaterial) return\n\n    this._overrideMaterial = overrideMaterial\n    this.overrideMaterial = null\n\n    const id = overrideMaterial.id\n    const version = (overrideMaterial as unknown as { version: number }).version\n\n    this.objectMaterials = {}\n\n    this.traverseDrawableObjects((object) => {\n      let material: Material = overrideMaterial\n\n      if (\n        isInstancedMesh(object) ||\n        isInstancedBufferGeometry(object.geometry)\n      ) {\n        let instancedMaterial = this.instancedOverrideMaterials[id]\n\n        if (instancedMaterial && instancedMaterial.version === version) {\n          material = instancedMaterial.material\n        } else {\n          material = overrideMaterial.clone()\n\n          if (instancedMaterial) {\n            instancedMaterial.material.dispose()\n            instancedMaterial.material = material\n            instancedMaterial.version = version\n          } else {\n            instancedMaterial = { version, material }\n          }\n\n          this.instancedOverrideMaterials[id] = instancedMaterial\n        }\n      }\n\n      this.objectMaterials![object.id] = object.material\n      object.material = material\n    })\n  }\n\n  private unsetOverrideMaterial(): void {\n    if (\n      !this.handleInstancedOverrideMaterials ||\n      !this._overrideMaterial\n    ) return\n\n    this.traverseDrawableObjects((object) => {\n      object.material = this.objectMaterials![object.id]\n    })\n\n    this.overrideMaterial = this._overrideMaterial\n    this._overrideMaterial = undefined\n    this.objectMaterials = undefined\n  }\n\n  public traverseDrawableObjects(\n    callback: (object: Mesh | Line | Points | InstancedMesh) => void\n  ): void {\n    if (!this.drawableObjects || this.drawableObjectsNeedUpdate) {\n      this.drawableObjectsNeedUpdate = false\n      this.drawableObjects = []\n\n      this.traverse((object) => {\n        if (\n          !isMesh(object) &&\n          !isLine(object) &&\n          !isPoints(object) &&\n          !isInstancedMesh(object)\n        ) return\n\n        object.visible && callback(object)\n        this.drawableObjects!.push(object)\n      })\n    } else {\n      this.drawableObjects.forEach(object => object.visible && callback(object))\n    }\n  }\n\n  public dispose(): void {\n    super.dispose()\n\n    this.drawableObjects = undefined\n\n    for (var id in this.instancedOverrideMaterials) {\n      const material = this.instancedOverrideMaterials[id].material\n      material.dispose()\n      delete this.instancedOverrideMaterials[id]\n    }\n  }\n}\n"],"names":["this","Vector3","Quaternion","Transition","_i","executors","transition","complete","animationsToComplete","length","animations","map","executor","pause","forEach","animation","stop","_this","undefined","console","log","scale","set","Matrix4","Object","Particle","appended","removed","start","show","hide","needsUpdate","matrix","compose","position","clone","add","quaternion","multiply","dispose","ParticleSourceMutation","isMesh","object","isInstancedMesh","_a","_b","_c","geometry","_d","material","_e","count","_f","color","_g","autoScale","_h","autoScaleAxis","_j","_super","tslib_1.__extends","ParticleSource","mesh","_geometry","v","updateGeometry","_material","updateMaterial","_color","Array","isArray","boundingBox","computeBoundingBox","size","getSize","x","y","z","mutation","prepare","Error","particle","Append","appendedParticles","particles","Remove","gltf","geometries","materials","scene","traverse","updateWorldMatrix","applyMatrix","matrixWorld","push","BufferGeometryUtils","mergeBufferGeometries","url","GLTFLoader","load","useGLTF","disposeMesh","InstancedMesh","frustumCulled","Math","min","createParticle","disposeParticles","remove","index","splice","update","setMatrixAt","instanceMatrix","prepareParticle","append","amount","completeAll","i","appendParticle","removeParticle","Object3D","Body","shape","shapes","indexOf","shapeOffsets","shapeOrientations","updateMassProperties","updateBoundingRadius","aabbNeedsUpdate","BaseBody","Infinity","Vec3","body","bodyParameters","PhysicalParticle","mass","type","DYNAMIC","velocity","angularVelocity","almostZero","freezeThreshold","frozen","freezing","STATIC","freezeVelocityFactor","freezeAngularVelocityFactor","freezeDelay","cancelFreeze","freezeTimeout","window","setTimeout","clearTimeout","requestFreeze","freeze","synchronizeBody","clearShapes","addShape","copy","w","world","parameters","PhysicalParticleSource","shape_1","createShape","setBodyShape","clearBodyShape","box","Box","max","resetBodyVelocity","resetBodyAngularVelocity","resetBodyPosition","resetBodyQuaternion","addBody","setOverrideMaterial","unsetOverrideMaterial","Scene","_onBeforeRender","_onAfterRender","handleInstancedOverrideMaterials","overrideMaterial","_overrideMaterial","id","version","objectMaterials","traverseDrawableObjects","isInstancedBufferGeometry","instancedMaterial","instancedOverrideMaterials","callback","drawableObjects","drawableObjectsNeedUpdate","isLine","isPoints","visible","BaseScene"],"mappings":"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"}
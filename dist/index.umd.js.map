{"version":3,"file":"index.umd.js","sources":["../src/transition.ts","../src/particle.ts","../src/particle-source.ts","../src/utils/decorators.ts","../src/utils/three.ts","../src/body.ts","../src/physical-particle.ts","../src/physical-particle-source.ts"],"sourcesContent":["import { Vector3, Quaternion } from 'three'\nimport { ParticleState } from '~/particle'\n\nexport interface Pausable {\n  pause(): void\n}\n\nexport type TransitionExecutor = (\n  transition: ParticleState,\n  complete: () => void\n) => Pausable | void | undefined\n\nexport class Transition implements ParticleState {\n  private animation?: Pausable\n  public readonly position: Vector3 = new Vector3()\n  public readonly quaternion: Quaternion = new Quaternion()\n  public readonly scale: Vector3 = new Vector3()\n\n  public static show: TransitionExecutor = (transition, complete) => {\n    transition.scale.set(1, 1, 1)\n    complete()\n  }\n\n  public static hide: TransitionExecutor = (transition, complete) => {\n    transition.scale.set(0, 0, 0)\n    complete()\n  }\n\n  public static compose(\n    ...executors: TransitionExecutor[]\n  ): TransitionExecutor {\n    return (transition: ParticleState, complete: () => void): Pausable => {\n      let animationsToComplete = executors.length\n      const animations = executors.map(executor => executor(transition, () => {\n        --animationsToComplete || complete()\n      }))\n\n      return {\n        pause: () => animations.forEach(animation => {\n          animation && animation.pause()\n        })\n      }\n    }\n  }\n\n  public start(executor: TransitionExecutor, complete: () => void): void {\n    this.stop()\n    this.animation = executor(this, () => {\n      complete()\n      this.animation = undefined\n    }) as Pausable | undefined\n  }\n\n  public stop(): void {\n    if (this.animation && !this.animation.pause) console.log(this.animation)\n    this.animation && this.animation.pause()\n  }\n\n  public dispose(): void {\n    this.animation && this.animation.pause()\n    this.animation = undefined\n  }\n}\n","import { Vector3, Quaternion, Matrix4 } from 'three'\nimport { Transition, TransitionExecutor } from '~/transition'\n\nexport interface ParticleState {\n  position: Vector3\n  quaternion: Quaternion\n  scale: Vector3\n}\n\nexport class Particle implements ParticleState {\n  public readonly position: Vector3 = new Vector3()\n  public readonly quaternion: Quaternion = new Quaternion()\n  public readonly scale: Vector3 = new Vector3(1, 1, 1)\n  public readonly matrix: Matrix4 = new Matrix4()\n  public readonly transition: Transition = new Transition()\n  public appended: boolean = false\n  public removed: boolean = false\n\n  public append(\n    transition?: TransitionExecutor,\n    complete?: (particle: this) => void\n  ): void {\n    this.appended = true\n    this.transition.start(transition || Transition.show, () => {\n      complete && complete(this)\n    })\n  }\n\n  public remove(\n    transition?: TransitionExecutor,\n    complete?: (particle: this) => void\n  ): void {\n    this.transition.start(transition || Transition.hide, () => {\n      this.removed = true\n      complete && complete(this)\n    })\n  }\n\n  public update(): boolean {\n    if (!this.appended) return false\n\n    this.matrix.compose(\n      this.position.clone().add(this.transition.position),\n      this.quaternion.clone().multiply(this.transition.quaternion),\n      this.scale.clone().multiply(this.transition.scale)\n    )\n\n    if (this.removed) {\n      this.appended = false\n      this.removed = false\n    }\n\n    return true\n  }\n\n  public dispose(): void {\n    this.transition.dispose()\n  }\n}\n","import {\n  Color,\n  Object3D,\n  Vector3,\n  Geometry,\n  BufferGeometry,\n  InstancedMesh,\n  MeshNormalMaterial\n} from 'three'\n\nimport { GLTF, GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader'\nimport { Particle } from '~/particle'\nimport { TransitionExecutor } from '~/transition'\nimport { lazy, mergeGLTF, ColoredMaterial } from '~/utils'\n\nenum ParticleSourceMutation {\n  Append = 1,\n  Remove = -1\n}\n\ninterface ParticleSourceTransitionExecutors {\n  append?: TransitionExecutor\n  remove?: TransitionExecutor\n}\n\nexport interface ParticleSourceMutationExecutors<\n  P extends Particle = Particle\n> {\n  prepare?: (particle: P) => void\n  complete?: (particle: P) => void\n  transition?: TransitionExecutor\n}\n\nexport interface ParticleSourceParameters {\n  geometry?: Geometry | BufferGeometry\n  material?: ColoredMaterial | ColoredMaterial[]\n  count?: number\n  color?: Color | number\n  autoScale?: number\n  transition?: ParticleSourceTransitionExecutors\n}\n\nexport class ParticleSource<P extends Particle = Particle> extends Object3D {\n  private mesh?: InstancedMesh\n  private normalMesh?: InstancedMesh\n  private _geometry?: Geometry | BufferGeometry\n  private _material?: ColoredMaterial | ColoredMaterial[]\n  private _color!: Color | number\n  private _usesNormalMaterial: boolean = false\n\n  protected particles: P[] = []\n  protected autoScale?: number\n\n  public appendedParticles: number = 0\n  public transition: ParticleSourceTransitionExecutors\n  public count: number\n\n  public constructor({\n    geometry = undefined,\n    material = undefined,\n    count = 0,\n    color = 0xffffff,\n    autoScale = undefined,\n    transition = {}\n  }: ParticleSourceParameters = {}) {\n    super()\n\n    this.transition = transition\n    this.autoScale = autoScale\n    this.geometry = geometry\n    this.material = material\n    this.color = color\n    this.count = count\n  }\n\n  @lazy private get normalMaterial(): MeshNormalMaterial {\n    return new MeshNormalMaterial({\n      morphTargets: true,\n      skinning: true\n    })\n  }\n\n  public get generated(): boolean {\n    return !!this.mesh\n  }\n\n  public get geometry(): Geometry | BufferGeometry | undefined {\n    return this._geometry\n  }\n\n  public set geometry(v: Geometry | BufferGeometry | undefined) {\n    this._geometry = v\n    this.updateGeometry()\n  }\n\n  public get material(): ColoredMaterial | ColoredMaterial[] | undefined {\n    return this._material\n  }\n\n  public set material(v: ColoredMaterial | ColoredMaterial[] | undefined) {\n    this._material = v\n    this.updateMaterial()\n  }\n\n  public get color(): Color | number {\n    return this._color\n  }\n\n  public set color(v: Color | number) {\n    this._color = v\n\n    if (!this.material) return\n\n    if (Array.isArray(this.material)) {\n      this.material.forEach(material => material.color.set(v as Color))\n    } else {\n      this.material.color.set(v as Color)\n    }\n  }\n\n  public get usesNormalMaterial(): boolean {\n    return this._usesNormalMaterial\n  }\n\n  public set usesNormalMaterial(v: boolean) {\n    this._usesNormalMaterial = v\n    if (!this.mesh || (!v && !this.material)) return\n    this.mesh.material = v ? this.normalMaterial : this.material!\n  }\n\n  protected updateGeometry(): void {\n    if (!this.geometry) return\n\n    if (this.autoScale !== undefined) {\n      this.geometry.boundingBox || this.geometry.computeBoundingBox()\n\n      const size = this.geometry.boundingBox.getSize(new Vector3())\n      let scale\n\n      if (\n        size.x > size.y && size.x < size.z ||\n        size.x < size.y && size.x > size.z\n      ) {\n        scale = size.x\n      } else if (\n        size.y > size.x && size.y < size.z ||\n        size.y < size.x && size.y > size.z\n      ) {\n        scale = size.y\n      } else {\n        scale = size.z\n      }\n\n      scale = this.autoScale / scale\n\n      this.geometry.scale(scale, scale, scale)\n    }\n\n    if (this.mesh) {\n      this.mesh.geometry = this.geometry\n    }\n  }\n\n  protected updateMaterial(): void {\n    if (!this.mesh || !this.material) return\n\n    if (Array.isArray(this.material)) {\n      this.material.forEach(material => material.color.set(this.color as Color))\n    } else {\n      this.material.color.set(this.color as Color)\n    }\n\n    if (!this.usesNormalMaterial) this.mesh.material = this.material\n  }\n\n  protected createParticle(): P {\n    return new Particle() as P\n  }\n\n  protected prepareParticle(\n    mutation: ParticleSourceMutation,\n    prepare?: (particle: P) => void\n  ): P {\n    if (!this.mesh) throw new Error(\n      'The mesh and particles have not been generated, ' +\n      'call generate() before calling appendParticle() or removeParticle()'\n    )\n\n    let particle!: P\n\n    switch (mutation) {\n      case ParticleSourceMutation.Append:\n        if (this.appendedParticles >= this.mesh.count) throw new Error(\n          `All ${this.mesh.count} particles have already been appended, ` +\n          'increase count and call generate() to append more particles.'\n        )\n\n        particle = this.particles[this.appendedParticles++]\n\n        break\n\n      case ParticleSourceMutation.Remove:\n        if (this.appendedParticles <= 0) throw new Error(\n          `All ${this.mesh.count} particles have already been removed, ` +\n          'you cannot remove more particles.'\n        )\n\n        particle = this.particles[--this.appendedParticles]\n\n        break\n    }\n\n    prepare && prepare(particle)\n\n    return particle\n  }\n\n  public useGLTF(gltf: GLTF): void {\n    const { geometry, material } = mergeGLTF(gltf)\n\n    this.geometry = geometry\n    this.material = material\n  }\n\n  public loadGLTF(url: string, complete?: (gltf: GLTF) => void): void {\n    new GLTFLoader().load(url, (gltf) => {\n      this.useGLTF(gltf)\n      complete && complete(gltf)\n    })\n  }\n\n  public generate(): void {\n    if (!this.geometry || !this.material) throw new Error(\n      'geometry and material must be set before calling generate()'\n    )\n\n    const {\n      particles,\n      count\n    } = this\n\n    this.disposeMesh()\n\n    this.mesh = new InstancedMesh(this.geometry, this.material, count)\n    this.mesh.frustumCulled = false\n\n    this.appendedParticles = Math.min(this.appendedParticles, count)\n    while (particles.length < count) particles.push(this.createParticle())\n    this.disposeParticles(count)\n\n    this.add(this.mesh)\n  }\n\n  public disposeMesh(): void {\n    if (!this.mesh) return\n\n    this.remove(this.mesh)\n    this.mesh = undefined\n  }\n\n  public disposeParticles(index: number = 0): void {\n    this.particles.splice(index).forEach(particle => particle.dispose())\n  }\n\n  public disposeGeometry(): void {\n    if (!this.geometry) return\n\n    this.geometry.dispose()\n    this.geometry = undefined\n  }\n\n  public disposeMaterial(): void {\n    if (!this.material) return\n\n    Array.isArray(this.material)\n      ? this.material.forEach(material => material.dispose())\n      : this.material.dispose()\n\n    this.material = undefined\n  }\n\n  public update(): void {\n    if (!this.mesh) return\n\n    const mesh = this.mesh\n\n    this.particles.forEach((particle, index) => {\n      if (!particle.update()) return\n      mesh.setMatrixAt(index, particle.matrix)\n      mesh.instanceMatrix.needsUpdate = true\n    })\n  }\n\n  public appendParticle({\n    prepare = undefined,\n    complete = undefined,\n    transition = this.transition.append\n  }: ParticleSourceMutationExecutors<P> = {}): void {\n    this\n      .prepareParticle(ParticleSourceMutation.Append, prepare)\n      .append(transition, complete)\n  }\n\n  public removeParticle({\n    prepare = undefined,\n    complete = undefined,\n    transition = this.transition.remove\n  }: ParticleSourceMutationExecutors<P> = {}): void {\n    this\n      .prepareParticle(ParticleSourceMutation.Remove, prepare)\n      .remove(transition, complete)\n  }\n\n  public appendParticles({\n    amount = Infinity,\n    complete = undefined,\n    completeAll = undefined,\n    ...executors\n  }: ParticleSourceMutationExecutors<P> & {\n    amount?: number\n    completeAll?: (particles: P[]) => void\n  } = {}): void {\n    const particles: P[] = []\n    amount = Math.min(amount, this.count - this.appendedParticles)\n\n    for (var i = 0; i < amount; i++) this.appendParticle({\n      ...executors,\n      complete: (particle) => {\n        particles.push(particle)\n        complete && complete(particle)\n        particles.length === amount && completeAll && completeAll(particles)\n      }\n    })\n  }\n\n  public removeParticles({\n    amount = Infinity,\n    complete = undefined,\n    completeAll = undefined,\n    ...executors\n  }: ParticleSourceMutationExecutors<P> & {\n    amount?: number\n    completeAll?: (particles: P[]) => void\n  } = {}): void {\n    const particles: P[] = []\n    amount = Math.min(amount, this.appendedParticles)\n\n    for (var i = 0; i < amount; i++) this.removeParticle({\n      ...executors,\n      complete: (particle) => {\n        particles.push(particle)\n        complete && complete(particle)\n        particles.length === amount && completeAll && completeAll(particles)\n      }\n    })\n  }\n}\n","export function lazy(\n  target: object,\n  property: string,\n  descriptor: PropertyDescriptor\n): void {\n  const get = descriptor.get!\n\n  descriptor.get = () => Object.defineProperty(target, property, {\n    value: get.call(target)\n  })[property]\n}\n","import {\n  Object3D,\n  Mesh,\n  Material,\n  Geometry,\n  BufferGeometry,\n  Color\n} from 'three'\n\nimport { GLTF } from 'three/examples/jsm/loaders/GLTFLoader'\n\nimport {\n  BufferGeometryUtils\n} from 'three/examples/jsm/utils/BufferGeometryUtils'\n\nexport type ColoredMaterial = Material & { color: Color }\n\nexport function isMesh(object: Object3D): object is Mesh {\n  return (object as unknown as Mesh).isMesh\n}\n\nexport function isBufferGeometry(\n  geometry: Geometry | BufferGeometry\n): geometry is BufferGeometry {\n  return (geometry as BufferGeometry).isBufferGeometry\n}\n\nexport function mergeGLTF(gltf: GLTF): {\n  geometry: BufferGeometry\n  material: ColoredMaterial | ColoredMaterial[]\n} {\n  const geometries: BufferGeometry[] = []\n  const materials: ColoredMaterial[] = []\n\n  gltf.scene.traverse((mesh) => {\n    if (!isMesh(mesh)) return\n\n    mesh.updateMatrixWorld(true)\n    mesh.geometry.applyMatrix(mesh.matrixWorld)\n\n    geometries.push(mesh.geometry as BufferGeometry)\n    materials.push(mesh.material as ColoredMaterial)\n  })\n\n  if (!geometries.length) throw new Error(\n    'Could not find any geometry in GLTF scene'\n  )\n\n  return {\n    geometry: geometries.length === 1\n      ? geometries[0]\n      : BufferGeometryUtils.mergeBufferGeometries(geometries, true),\n\n    material: materials.length === 1\n      ? materials[0]\n      : materials\n  }\n}\n","import { Body as BaseBody, Shape } from 'cannon'\n\nexport class Body extends BaseBody {\n  public removeShape(shape: Shape): this {\n    const index = this.shapes.indexOf(shape)\n\n    if (index !== -1) {\n      this.shapes.splice(index, 1)\n      this.shapeOffsets.splice(index, 1)\n      this.shapeOrientations.splice(index, 1)\n\n      this.updateMassProperties()\n      this.updateBoundingRadius()\n\n      this.aabbNeedsUpdate = true\n    }\n\n    return this\n  }\n\n  public clearShapes(update: boolean = true): this {\n    if (this.shapes.length) {\n      this.shapes.splice(0)\n      this.shapeOffsets.splice(0)\n      this.shapeOrientations.splice(0)\n\n      if (update) {\n        this.updateMassProperties()\n        this.updateBoundingRadius()\n\n        this.aabbNeedsUpdate = true\n      }\n    }\n\n    return this\n  }\n}\n","import { Shape, Vec3 } from 'cannon'\nimport { Vector3, Quaternion } from 'three'\nimport { Particle } from '~/particle'\nimport { Body } from '~/body'\nimport { TransitionExecutor } from '~/transition'\n\nexport class PhysicalParticle extends Particle {\n  protected readonly freezeDelay: number = Infinity\n  protected readonly freezeVelocityFactor: Vec3 = new Vec3(0.9, 1, 0.9)\n  protected readonly freezeAngularVelocityFactor: Vec3 = new Vec3(1, 1, 1)\n  protected readonly freezeThreshold: number = 0.001\n  protected freezeTimeout?: number\n  protected freezing: boolean = false\n  protected frozen: boolean = false\n\n  public readonly body: Body\n\n  public constructor() {\n    super()\n    this.body = new Body(this.bodyParameters)\n  }\n\n  protected get bodyParameters(): { [parameter: string]: unknown } {\n    return {\n      mass: 1,\n      type: Body.DYNAMIC\n    }\n  }\n\n  protected freeze(): void {\n    const { velocity,  angularVelocity } = this.body\n\n    if (velocity.almostZero(this.freezeThreshold)) {\n      this.frozen = true\n      this.freezing = false\n\n      this.body.type = Body.STATIC\n\n      return\n    }\n\n    const { freezeVelocityFactor, freezeAngularVelocityFactor } = this\n\n    velocity.x *= freezeVelocityFactor.x\n    velocity.y *= freezeVelocityFactor.y\n    velocity.z *= freezeVelocityFactor.z\n\n    angularVelocity.x *= freezeAngularVelocityFactor.x\n    angularVelocity.y *= freezeAngularVelocityFactor.y\n    angularVelocity.z *= freezeAngularVelocityFactor.z\n  }\n\n  protected requestFreeze(): void {\n    if (this.freezeDelay === Infinity) return\n    this.cancelFreeze()\n    this.freezeTimeout = window.setTimeout(() => {\n      this.freezing = true\n    }, this.freezeDelay)\n  }\n\n  protected cancelFreeze(): void {\n    if (this.freezeTimeout === undefined) return\n    clearTimeout(this.freezeTimeout)\n    this.freezeTimeout = undefined\n  }\n\n  public append(\n    transition?: TransitionExecutor,\n    complete?: (particle: this) => void\n  ): void {\n    this.freezing = this.frozen = false\n    this.body.type = Body.DYNAMIC\n    super.append(transition, (particle) => {\n      this.requestFreeze()\n      complete && complete(particle)\n    })\n  }\n\n  public remove(\n    transition?: TransitionExecutor,\n    complete?: (particle: this) => void\n  ): void {\n    this.cancelFreeze()\n    super.remove(transition, complete)\n  }\n\n  public update(): boolean {\n    if (!this.appended) return false\n    this.freezing && this.freeze()\n    this.frozen || this.synchronizeBody()\n    return super.update()\n  }\n\n  public clearBodyShape(): void {\n    this.body.clearShapes()\n  }\n\n  public setBodyShape(shape: Shape): void {\n    this.body.clearShapes(false)\n    this.body.addShape(shape)\n  }\n\n  public synchronizeBody(): void {\n    this.position.copy(this.body.position as unknown as Vector3)\n    this.quaternion.copy(this.body.quaternion as unknown as Quaternion)\n  }\n\n  public resetBodyPosition(): void {\n    const { x, y, z } = this.position\n    this.body.position.set(x, y, z)\n  }\n\n  public resetBodyQuaternion(): void {\n    const { x, y, z, w } = this.quaternion\n    this.body.quaternion.set(x, y, z, w)\n  }\n\n  public resetBodyVelocity(): void {\n    this.body.velocity.set(0, 0, 0)\n  }\n\n  public resetBodyAngularVelocity(): void {\n    this.body.angularVelocity.set(0, 0, 0)\n  }\n}\n","import { World, Box, Vec3, Shape } from 'cannon'\nimport { PhysicalParticle } from '~/physical-particle'\n\nimport {\n  ParticleSource,\n  ParticleSourceParameters,\n  ParticleSourceMutationExecutors\n} from '~/particle-source'\n\nexport interface PhysicalParticleSourceParameters\n  extends ParticleSourceParameters {\n  world: World\n}\n\nexport class PhysicalParticleSource extends ParticleSource<PhysicalParticle> {\n  public readonly world: World\n  protected shape?: Shape\n\n  public constructor({\n    world,\n    ...parameters\n  }: PhysicalParticleSourceParameters) {\n    super(parameters)\n    this.world = world\n  }\n\n  protected updateGeometry(): void {\n    super.updateGeometry()\n\n    if (this.geometry) {\n      const shape = this.shape = this.createShape()\n      this.particles.forEach(particle => particle.setBodyShape(shape))\n    } else {\n      this.particles.forEach(particle => particle.clearBodyShape())\n    }\n  }\n\n  protected createShape(): Shape {\n    this.geometry!.boundingBox || this.geometry!.computeBoundingBox()\n\n    const box = this.geometry!.boundingBox\n\n    return new Box(new Vec3(\n      (box.max.x - box.min.x) / 2,\n      (box.max.y - box.min.y) / 2,\n      (box.max.z - box.min.z) / 2\n    ))\n  }\n\n  protected createParticle(): PhysicalParticle {\n    const particle = new PhysicalParticle()\n    this.shape && particle.setBodyShape(this.shape)\n    return particle\n  }\n\n  public appendParticle({\n    prepare = undefined,\n    ...executors\n  }: ParticleSourceMutationExecutors<PhysicalParticle> = {}): void {\n    super.appendParticle({\n      ...executors,\n      prepare: (particle) => {\n        particle.resetBodyVelocity()\n        particle.resetBodyAngularVelocity()\n\n        prepare && prepare(particle)\n\n        particle.resetBodyPosition()\n        particle.resetBodyQuaternion()\n\n        this.world.addBody(particle.body)\n      }\n    })\n  }\n\n  public removeParticle({\n    complete = undefined,\n    ...executors\n  }: ParticleSourceMutationExecutors<PhysicalParticle> = {}): void {\n    super.removeParticle({\n      ...executors,\n      complete: (particle) => {\n        this.world.remove(particle.body)\n        complete && complete(particle)\n      }\n    })\n  }\n}\n"],"names":["this","Vector3","Quaternion","Transition","_i","executors","transition","complete","animationsToComplete","length","animations","map","executor","pause","forEach","animation","stop","_this","undefined","console","log","scale","set","Matrix4","Particle","appended","start","show","hide","removed","matrix","compose","position","clone","add","quaternion","multiply","dispose","ParticleSourceMutation","lazy","target","property","descriptor","get","Object","defineProperty","value","call","_a","_b","_c","geometry","_d","material","_e","count","_f","color","_g","autoScale","_h","_super","tslib_1.__extends","ParticleSource","MeshNormalMaterial","morphTargets","skinning","mesh","_geometry","v","updateGeometry","_material","updateMaterial","_color","Array","isArray","_usesNormalMaterial","normalMaterial","boundingBox","computeBoundingBox","size","getSize","x","y","z","usesNormalMaterial","mutation","prepare","Error","particle","Append","appendedParticles","particles","Remove","gltf","geometries","materials","scene","traverse","isMesh","updateMatrixWorld","applyMatrix","matrixWorld","push","BufferGeometryUtils","mergeBufferGeometries","url","GLTFLoader","load","useGLTF","disposeMesh","InstancedMesh","frustumCulled","Math","min","createParticle","disposeParticles","remove","index","splice","update","setMatrixAt","instanceMatrix","needsUpdate","prepareParticle","append","amount","completeAll","i","appendParticle","removeParticle","tslib_1.__decorate","Object3D","Body","shape","shapes","indexOf","shapeOffsets","shapeOrientations","updateMassProperties","updateBoundingRadius","aabbNeedsUpdate","BaseBody","Infinity","Vec3","body","bodyParameters","PhysicalParticle","mass","type","DYNAMIC","velocity","angularVelocity","almostZero","freezeThreshold","frozen","freezing","STATIC","freezeVelocityFactor","freezeAngularVelocityFactor","freezeDelay","cancelFreeze","freezeTimeout","window","setTimeout","clearTimeout","requestFreeze","freeze","synchronizeBody","clearShapes","addShape","copy","w","world","parameters","PhysicalParticleSource","shape_1","createShape","setBodyShape","clearBodyShape","box","Box","max","resetBodyVelocity","resetBodyAngularVelocity","resetBodyPosition","resetBodyQuaternion","addBody"],"mappings":"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"}
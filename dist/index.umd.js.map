{"version":3,"file":"index.umd.js","sources":["../src/transition.ts","../src/particle.ts","../src/utils.ts","../src/particle-source.ts"],"sourcesContent":["import { Vector3, Quaternion } from 'three'\nimport { ParticleState } from '~/particle'\n\nexport interface Pausable {\n  pause(): void\n}\n\nexport type TransitionExecutor = (\n  transition: ParticleState,\n  complete: () => void\n) => Pausable | void | undefined\n\nexport class Transition implements ParticleState {\n  private animation?: Pausable\n  public readonly position: Vector3 = new Vector3()\n  public readonly quaternion: Quaternion = new Quaternion()\n  public readonly scale: Vector3 = new Vector3()\n\n  public static show: TransitionExecutor = (transition, complete) => {\n    transition.scale.set(1, 1, 1)\n    complete()\n  }\n\n  public static hide: TransitionExecutor = (transition, complete) => {\n    transition.scale.set(0, 0, 0)\n    complete()\n  }\n\n  public static compose(\n    ...executors: TransitionExecutor[]\n  ): TransitionExecutor {\n    return (transition: ParticleState, complete: () => void): Pausable => {\n      let animationsToComplete = executors.length\n      const animations = executors.map(executor => executor(transition, () => {\n        --animationsToComplete || complete()\n      }))\n\n      return {\n        pause: () => animations.forEach(animation => {\n          animation && animation.pause()\n        })\n      }\n    }\n  }\n\n  public start(executor: TransitionExecutor, complete: () => void): void {\n    this.stop()\n    this.animation = executor(this, () => {\n      complete()\n      this.animation = undefined\n    }) as Pausable | undefined\n  }\n\n  public stop(): void {\n    if (this.animation && !this.animation.pause) console.log(this.animation)\n    this.animation && this.animation.pause()\n  }\n\n  public dispose(): void {\n    this.animation && this.animation.pause()\n    this.animation = undefined\n  }\n}\n","import { Vector3, Quaternion, Matrix4 } from 'three'\nimport { Transition, TransitionExecutor } from '~/transition'\n\nexport interface ParticleState {\n  position: Vector3\n  quaternion: Quaternion\n  scale: Vector3\n}\n\nexport class Particle implements ParticleState {\n  public readonly position: Vector3 = new Vector3()\n  public readonly quaternion: Quaternion = new Quaternion()\n  public readonly scale: Vector3 = new Vector3(1, 1, 1)\n  public readonly matrix: Matrix4 = new Matrix4()\n  public readonly transition: Transition = new Transition()\n  public appended: boolean = false\n\n  public append(transition?: TransitionExecutor, complete?: () => void): void {\n    this.appended = true\n    this.transition.start(transition || Transition.show, () => {\n      complete && complete()\n    })\n  }\n\n  public remove(transition?: TransitionExecutor, complete?: () => void): void {\n    this.transition.start(transition || Transition.hide, () => {\n      this.appended = false\n      complete && complete()\n    })\n  }\n\n  public update(): boolean {\n    if (!this.appended) return false\n\n    this.matrix.compose(\n      this.position.clone().add(this.transition.position),\n      this.quaternion.clone().multiply(this.transition.quaternion),\n      this.scale.clone().multiply(this.transition.scale)\n    )\n\n    return true\n  }\n\n  public dispose(): void {\n    this.transition.dispose()\n  }\n}\n","export const lazy = (\n  target: object,\n  property: string,\n  descriptor: PropertyDescriptor\n): void => {\n  const get = descriptor.get!\n\n  descriptor.get = () => Object.defineProperty(target, property, {\n    value: get.call(target)\n  })[property]\n}\n","import {\n  Color,\n  Object3D,\n  Geometry,\n  Material,\n  InstancedMesh,\n  MeshNormalMaterial\n} from 'three'\n\nimport { Particle } from '~/particle'\nimport { TransitionExecutor } from '~/transition'\nimport { lazy } from '~/utils'\n\ntype ColoredMaterial = Material & { color: Color }\n\nenum ParticleSourceMutation {\n  Append = 1,\n  Remove = -1\n}\n\ninterface ParticleSourceTransitionExecutors {\n  append?: TransitionExecutor\n  remove?: TransitionExecutor\n}\n\ninterface ParticleSourceMutationExecutors {\n  prepare?: (particle: Particle) => void\n  complete?: () => void\n  transition?: TransitionExecutor\n}\n\nexport class ParticleSource extends Object3D {\n  private particles: Particle[] = []\n  private mesh?: InstancedMesh\n  private normalMesh?: InstancedMesh\n  private _geometry?: Geometry\n  private _material?: ColoredMaterial\n  private _color!: Color | number\n  private _usesNormalMaterial: boolean = false\n\n  public appendedParticles: number = 0\n  public transition: ParticleSourceTransitionExecutors\n  public count: number\n\n  public constructor({\n    geometry = undefined,\n    material = undefined,\n    count = 0,\n    color = 0xffffff,\n    transition = {}\n  }: {\n    geometry?: Geometry\n    material?: ColoredMaterial\n    count?: number\n    color?: Color | number\n    transition?: ParticleSourceTransitionExecutors\n  } = {}) {\n    super()\n\n    this.transition = transition\n    this.geometry = geometry\n    this.material = material\n    this.color = color\n    this.count = count\n  }\n\n  @lazy private get normalMaterial(): MeshNormalMaterial {\n    return new MeshNormalMaterial({\n      morphTargets: true,\n      skinning: true\n    })\n  }\n\n  public get generated(): boolean {\n    return !!this.mesh\n  }\n\n  public get geometry(): Geometry | undefined {\n    return this._geometry\n  }\n\n  public set geometry(v: Geometry | undefined) {\n    this._geometry = v\n    if (!this.mesh || !v) return\n    this.mesh.geometry = v\n  }\n\n  public get material(): ColoredMaterial | undefined {\n    return this._material\n  }\n\n  public set material(v: ColoredMaterial | undefined) {\n    this._material = v\n    if (!this.mesh || !v) return\n    v.color.set(this.color as Color)\n    if (!this.usesNormalMaterial) this.mesh.material = v\n  }\n\n  public get color(): Color | number {\n    return this._color\n  }\n\n  public set color(v: Color | number) {\n    this._color = v\n    this.material && this.material.color.set(v as Color)\n  }\n\n  public get usesNormalMaterial(): boolean {\n    return this._usesNormalMaterial\n  }\n\n  public set usesNormalMaterial(v: boolean) {\n    this._usesNormalMaterial = v\n    if (!this.mesh || (!v && !this.material)) return\n    this.mesh.material = v ? this.normalMaterial : this.material!\n  }\n\n  protected createParticle(): Particle {\n    return new Particle()\n  }\n\n  protected prepareParticle(\n    mutation: ParticleSourceMutation,\n    prepare?: (particle: Particle) => void\n  ): Particle {\n    if (!this.mesh) throw new Error(\n      'The mesh and particles have not been generated, ' +\n      'call generate() before calling appendParticle() or removeParticle()'\n    )\n\n    let particle!: Particle\n\n    switch (mutation) {\n      case ParticleSourceMutation.Append:\n        if (this.appendedParticles >= this.mesh.count) throw new Error(\n          `All ${this.mesh.count} particles have already been appended, ` +\n          'increase count and call generate() to append more particles.'\n        )\n\n        particle = this.particles[this.appendedParticles++]\n\n        break\n\n      case ParticleSourceMutation.Remove:\n        if (this.appendedParticles <= 0) throw new Error(\n          `All ${this.mesh.count} particles have already been removed, ` +\n          'you cannot remove more particles.'\n        )\n\n        particle = this.particles[--this.appendedParticles]\n\n        break\n    }\n\n    prepare && prepare(particle)\n\n    return particle\n  }\n\n  public generate(): void {\n    if (!this.geometry || !this.material) throw new Error(\n      'geometry and material must be set before calling generate()'\n    )\n\n    const {\n      particles,\n      count\n    } = this\n\n    this.dispose()\n\n    this.mesh = new InstancedMesh(this.geometry, this.material, count)\n    this.mesh.frustumCulled = false\n\n    this.appendedParticles = Math.min(this.appendedParticles, count)\n    while (particles.length < count) particles.push(this.createParticle())\n    particles.splice(count).forEach(particle => particle.dispose())\n\n    this.add(this.mesh)\n  }\n\n  public dispose(all: boolean = false): void {\n    if (this.mesh) {\n      this.remove(this.mesh)\n      this.mesh = undefined\n    }\n\n    if (all) {\n      this.particles.splice(0).forEach(particle => particle.dispose())\n    }\n  }\n\n  public update(): void {\n    if (!this.mesh) return\n\n    const mesh = this.mesh\n\n    this.particles.forEach((particle, index) => {\n      if (!particle.update()) return\n      mesh.setMatrixAt(index, particle.matrix)\n      mesh.instanceMatrix.needsUpdate = true\n    })\n  }\n\n  public appendParticle({\n    prepare = undefined,\n    complete = undefined,\n    transition = this.transition.append\n  }: ParticleSourceMutationExecutors = {}): void {\n    this\n      .prepareParticle(ParticleSourceMutation.Append, prepare)\n      .append(transition, complete)\n  }\n\n  public removeParticle({\n    prepare = undefined,\n    complete = undefined,\n    transition = this.transition.remove\n  }: ParticleSourceMutationExecutors = {}): void {\n    this\n      .prepareParticle(ParticleSourceMutation.Remove, prepare)\n      .append(transition, complete)\n  }\n}\n"],"names":["this","Vector3","Quaternion","Transition","_i","executors","transition","complete","animationsToComplete","length","animations","map","executor","pause","forEach","animation","stop","_this","undefined","console","log","scale","set","Matrix4","Particle","appended","start","show","hide","matrix","compose","position","clone","add","quaternion","multiply","dispose","ParticleSourceMutation","lazy","target","property","descriptor","get","Object","defineProperty","value","call","_a","_b","_c","geometry","_d","material","_e","count","_f","color","_g","_super","tslib_1.__extends","ParticleSource","MeshNormalMaterial","morphTargets","skinning","mesh","_geometry","v","_material","usesNormalMaterial","_color","_usesNormalMaterial","normalMaterial","mutation","prepare","Error","particle","Append","appendedParticles","particles","Remove","InstancedMesh","frustumCulled","Math","min","push","createParticle","splice","all","remove","index","update","setMatrixAt","instanceMatrix","needsUpdate","prepareParticle","append","tslib_1.__decorate","Object3D"],"mappings":"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"}